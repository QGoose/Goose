@book{Chuang2010,
  author    = {{Nielsen},{M.A.} and {Chuang}, {I.L.}},
  title     = {{Quantum} {Computation} and {Quantum} {Information}: {10th} {Anniversary} {Edition}},
  publisher = {{Cambridge} {University} {Press}},
  year      = {2010}
}

@misc{CirqDevelopers2018,
 title = {Cirq},
 author = {{Cirq Developers}},
 year = {2018},
 month = {July},
 doi = {10.5281/zenodo.4062499},
 url = {https://github.com/quantumlib/Cirq},
 abstract = {Cirq is a Python library for writing, manipulating, and optimizing quantum circuits and running them against quantum computers and simulators.},
 webnote = {See full list of authors on Github: \url{https://github.com/quantumlib/Cirq/graphs/contributors}},
 bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}

@article{Hietala2021,
 title = {A Verified Optimizer for {{Quantum}} Circuits},
 author = {Hietala, Kesha and Rand, Robert and Hung, Shih-Han and Wu, Xiaodi and Hicks, Michael},
 year = {2021},
 month = {January},
 journal = {Proceedings of the ACM on Programming Languages},
 volume = {5},
 number = {POPL},
 eid = {37},
 pages = {37},
 numpages = {29},
 doi = {10.1145/3434318},
 archiveprefix = {arXiv},
 eprint = {1912.02250},
 url = {https://github.com/inQWIRE/SQIR},
 abstract = {We present VOQC, the first fully verified optimizer for quantum circuits, written using the Coq proof assistant. Quantum circuits are expressed as programs in a simple, low-level language called SQIR, a simple quantum intermediate representation, which is deeply embedded in Coq. Optimizations and other transformations are expressed as Coq functions, which are proved correct with respect to a semantics of SQIR programs. SQIR uses a semantics of matrices of complex numbers, which is the standard for quantum computation, but treats matrices symbolically in order to reason about programs that use an arbitrary number of quantum bits. SQIR's careful design and our provided automation make it possible to write and verify a broad range of optimizations in VOQC, including full-circuit transformations from cutting-edge optimizers.},
 keywords = {programming languages, formal verification, certified compilation, quantum computing, circuit optimization},
 webnote = {POPL '21. See arXiv version for full paper with appendix.},
 bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}

@misc{Quil2016,
    title={A Practical Quantum Instruction Set Architecture},
    author={Robert S. Smith and Michael J. Curtis and William J. Zeng},
    year={2016},
    eprint={1608.03355},
    archivePrefix={arXiv},
    primaryClass={quant-ph}
}

@article{Gyongyosi2019,
  abstract   = {The power of quantum computing technologies is based on the fundamentals of quantum mechanics, such as quantum superposition, quantum entanglement, or the no-cloning theorem. Since these phenomena have no classical analogue, similar results cannot be achieved within the framework of traditional computing. The experimental insights of quantum computing technologies have already been demonstrated, and several studies are in progress. Here we review the most recent results of quantum computation technology and address the open problems of the field.},
  author     = {Laszlo Gyongyosi and Sandor Imre},
  doi        = {https://doi.org/10.1016/j.cosrev.2018.11.002},
  issn       = {1574-0137},
  journal    = {Computer Science Review},
  keywords   = {Quantum computations, Quantum information processing, Quantum computer, Quantum entanglement},
  pages      = {51-71},
  title      = {A Survey on quantum computing technology},
  url        = {https://www.sciencedirect.com/science/article/pii/S1574013718301709},
  volume     = {31},
  year       = {2019},
  bdsk-url-1 = {https://www.sciencedirect.com/science/article/pii/S1574013718301709},
  bdsk-url-2 = {https://doi.org/10.1016/j.cosrev.2018.11.002}
}

@article{Preskill2018,
  doi       = {10.22331/q-2018-08-06-79},
  url       = {https://doi.org/10.22331/q-2018-08-06-79},
  title     = {Quantum {C}omputing in the {NISQ} era and beyond},
  author    = {Preskill, John},
  journal   = {{Quantum}},
  issn      = {2521-327X},
  publisher = {{Verein zur F{\"{o}}rderung des Open Access Publizierens in den Quantenwissenschaften}},
  volume    = {2},
  pages     = {79},
  month     = aug,
  year      = {2018}
}

@article{Cross2022,
  title         = {OpenQASM 3: A Broader and Deeper Quantum Assembly Language},
  author        = {Cross, Andrew W. and Javadi-Abhari, Ali and Alexander, Thomas and de Beaudrap, Niel and Bishop, Lev S. and Heidel, Steven and Ryan, Colm A. and Sivarajah, Prasahnt and Smolin, John and Gambetta, Jay M. and Johnson, Blake R.},
  year          = {2022},
  month         = {September},
  journal       = {ACM Transactions on Quantum Computing},
  publisher     = {{Association for Computing Machinery}},
  address       = {{New York, NY, USA}},
  volume        = {3},
  number        = {3},
  eid           = {12},
  pages         = {12},
  numpages      = {50},
  doi           = {10.1145/3505636},
  archiveprefix = {arXiv},
  eprint        = {2104.14722},
  url           = {https://openqasm.com/},
  abstract      = {Quantum assembly languages are machine-independent languages that traditionally describe quantum computation in the circuit model. Open quantum assembly language (OpenQASM 2) was proposed as an imperative programming language for quantum circuits based on earlier QASM dialects. In principle, any quantum computation could be described using OpenQASM 2, but there is a need to describe a broader set of circuits beyond the language of qubits and gates. By examining interactive use cases, we recognize two different timescales of quantum-classical interactions: real-time classical computations that must be performed within the coherence times of the qubits, and near-time computations with less stringent timing. Since the near-time domain is adequately described by existing programming frameworks, we choose in OpenQASM 3 to focus on the real-time domain, which must be more tightly coupled to the execution of quantum operations. We add support for arbitrary control flow as well as calling external classical functions. In addition, we recognize the need to describe circuits at multiple levels of specificity, and therefore we extend the language to include timing, pulse control, and gate modifiers. These new language features create a multi-level intermediate representation for circuit development and optimization, as well as control sequence implementation for calibration, characterization, and error mitigation.},
  keywords      = {qasm, quantum assembly language, openqasm, quantum computing, quantum information},
  webnote       = {See \cite{Cross2017} for OpenQASM 2.0},
  bibsource     = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}

@misc{Qiskit,
  title = {Qiskit: An Open-source Framework for Quantum Computing},
  url   = {https://qiskit.org}
}

@inproceedings{Green2013a,
  title         = {An {{Introduction}} to {{Quantum Programming}} in {{Quipper}}},
  author        = {Green, Alexander S. and Lumsdaine, Peter LeFanu and Ross, Neil J. and Selinger, Peter and Valiron, Beno{\^i}t},
  year          = {2013},
  month         = {July},
  booktitle     = {Reversible Computation (RC '13)},
  editor        = {Dueck, Gerhard W. and Miller, D. Michael},
  publisher     = {Springer},
  address       = {Berlin, Heidelberg},
  series        = {Lecture Notes in Computer Science},
  volume        = {7948},
  pages         = {110--124},
  doi           = {10.1007/978-3-642-38986-3_10},
  archiveprefix = {arXiv},
  eprint        = {1304.5485},
  abstract      = {Quipper is a recently developed programming language for expressing quantum computations. This paper gives a brief tutorial introduction to the language, through a demonstration of how to make use of some of its key features. We illustrate many of Quipper's language features by developing a few well known examples of Quantum computation, including quantum teleportation, the quantum Fourier transform, and a quantum circuit for addition.},
  keywords      = {quantum computation, programming languages, quipper},
  bibsource     = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}

@inproceedings{Green2013,
  title         = {Quipper: {{A Scalable Quantum Programming Language}}},
  shorttitle    = {Quipper},
  author        = {Green, Alexander S. and Lumsdaine, Peter LeFanu and Ross, Neil J. and Selinger, Peter and Valiron, Beno{\^i}t},
  year          = {2013},
  month         = {June},
  booktitle     = {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  publisher     = {{Association for Computing Machinery}},
  address       = {{New York, NY, USA}},
  series        = {{{PLDI}} '13},
  pages         = {333--342},
  doi           = {10.1145/2491956.2462177},
  archiveprefix = {arXiv},
  eprint        = {1304.3390},
  abstract      = {The field of quantum algorithms is vibrant. Still, there is currently a lack of programming languages for describing quantum computation on a practical scale, i.e., not just at the level of toy problems. We address this issue by introducing Quipper, a scalable, expressive, functional, higher-order quantum programming language. Quipper has been used to program a diverse set of non-trivial quantum algorithms, and can generate quantum gate representations using trillions of gates. It is geared towards a model of computation that uses a classical computer to control a quantum device, but is not dependent on any particular model of quantum hardware. Quipper has proven effective and easy to use, and opens the door towards using formal methods to analyze quantum algorithms.},
  keywords      = {quipper, quantum programming languages},
  bibsource     = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}

@article{Yuan2022a,
  title         = {Tower: Data Structures in Quantum Superposition},
  author        = {Yuan, Charles and Carbin, Michael},
  year          = {2022},
  month         = {September},
  journal       = {Proceedings of the ACM on Programming Languages},
  volume        = {6},
  number        = {OOPSLA2},
  eid           = {134},
  pages         = {134},
  numpages      = {30},
  doi           = {10.1145/3563297},
  archiveprefix = {arXiv},
  eprint        = {2205.10255},
  url           = {https://github.com/psg-mit/tower-oopsla22},
  abstract      = {Emerging quantum algorithms for problems such as element distinctness, subset sum, and closest pair demonstrate computational advantages by relying on abstract data structures. Practically realizing such an algorithm as a program for a quantum computer requires an efficient implementation of the data structure whose operations correspond to unitary operators that manipulate quantum superpositions of data.
                   
                   To correctly operate in superposition, an implementation must satisfy three properties -- reversibility, history independence, and bounded-time execution. Standard implementations, such as the representation of an abstract set as a hash table, fail these properties, calling for tools to develop specialized implementations.
                   
                   In this work, we present Core Tower, the first language for quantum programming with random-access memory. Core Tower enables the developer to implement data structures as pointer-based, linked data. It features a reversible semantics enabling every valid program to be translated to a unitary quantum circuit.
                   
                   We present Boson, the first memory allocator that supports reversible, history-independent, and constant-time dynamic memory allocation in quantum superposition. We also present Tower, a language for quantum programming with recursively defined data structures. Tower features a type system that bounds all recursion using classical parameters as is necessary for a program to execute on a quantum computer.
                   
                   Using Tower, we implement Ground, the first quantum library of data structures, including lists, stacks, queues, strings, and sets. We provide the first executable implementation of sets that satisfies all three mandated properties of reversibility, history independence, and bounded-time execution.},
  keywords      = {quantum programming, data structures, quantum random-access memory, reversible programming, history independence},
  note          = {To appear},
  webnote       = {OOPSLA '22. See arXiv version for full paper with appendix.},
  bibsource     = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}

@inproceedings{Svore2018,
  title         = {Q\#: {{Enabling Scalable Quantum Computing}} and {{Development}} with a {{High}}-Level {{DSL}}},
  shorttitle    = {Q\#},
  author        = {Svore, Krysta M. and Geller, Alan and Troyer, Matthias and Azariah, John and Granade, Christopher E. and Heim, Bettina and Kliuchnikov, Vadym and Mykhailova, Mariia and Paz, Andres and Roetteler, Martin},
  year          = {2018},
  month         = {February},
  booktitle     = {Proceedings of the Real World Domain Specific Languages Workshop 2018},
  publisher     = {{Association for Computing Machinery}},
  address       = {{New York, NY, USA}},
  series        = {{{RWDSL}} '18},
  eid           = {7},
  pages         = {7},
  numpages      = {10},
  doi           = {10.1145/3183895.3183901},
  archiveprefix = {arXiv},
  eprint        = {1803.00652},
  abstract      = {Quantum computing exploits quantum phenomena such as superposition and entanglement to realize a form of parallelism that is not available to traditional computing. It offers the potential of significant computational speed-ups in quantum chemistry, materials science, cryptography, and machine learning. The dominant approach to programming quantum computers is to provide an existing high-level language with libraries that allow for the expression of quantum programs. This approach can permit computations that are meaningless in a quantum context; prohibits succinct expression of interaction between classical and quantum logic; and does not provide important constructs that are required for quantum programming. We present Q\#, a quantum-focused domain-specific language explicitly designed to correctly, clearly and completely express quantum algorithms. Q\# provides a type system; a tightly constrained environment to safely interleave classical and quantum computations; specialized syntax; symbolic code manipulation to automatically generate correct transformations of quantum operations; and powerful functional constructs which aid composition.},
  keywords      = {domain specific language, functional programming, quantum computing, q\#},
  webnote       = {See also Ch. 8 of \cite{Heim2020}},
  bibsource     = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}

@inproceedings{Paykin2017,
  title     = {{{QWIRE}}: A Core Language for Quantum Circuits},
  author    = {Paykin, Jennifer and Rand, Robert and Zdancewic, Steve},
  year      = {2017},
  month     = {January},
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  publisher = {{Association for Computing Machinery}},
  address   = {{New York, NY, USA}},
  series    = {{{POPL}} '17},
  pages     = {846--858},
  doi       = {10.1145/3009837.3009894},
  url       = {https://jpaykin.github.io/papers/prz_qwire_2017.pdf},
  abstract  = {This paper introduces QWIRE (``choir''), a language for defining quantum circuits and an interface for manipulating them inside of an arbitrary classical host language. QWIRE is minimal---it contains only a few primitives---and sound with respect to the physical properties entailed by quantum mechanics. At the same time, QWIRE is expressive and highly modular due to its relationship with the host language, mirroring the QRAM model of computation that places a quantum computer (controlled by circuits) alongside a classical computer (controlled by the host language).
               
               We present QWIRE along with its type system and operational semantics, which we prove is safe and strongly normalizing whenever the host language is. We give circuits a denotational semantics in terms of density matrices. Throughout, we investigate examples that demonstrate the expressive power of QWIRE, including extensions to the host language that (1) expose a general analysis framework for circuits, and (2) provide dependent types.},
  keywords  = {linear types, denotational semantics, quantum circuits, quantum programming languages},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}

%% The following 2 entries are for OQaml
@misc{oqaml2017.0.0.1,
  author       = {Rigetti Computing},
  title        = {OQaml},
  year         = {2017},
  publisher    = {GitHub},
  journal      = {GitHub repository},
  howpublished = {\url{https://github.com/rigetticomputing}}
}

@misc{1608.03355,
  title   = {A Practical Quantum Instruction Set Architecture},
  author  = {Smith, Robert S and Curtis, Michael J and Zeng, William J},
  journal = {arXiv preprint arXiv:1608.03355},
  year    = {2016}
}